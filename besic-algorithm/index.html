<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>Basic algorithm</title>
</head>
<body>
<script>

    /** Stack **/

    const Stack = function () {
        let item = [];

        this.push = function (target) {
            item.push(target);
        }
        this.pop = function () {
            return item.pop();
        }
        this.peek = function () {
            return item[item.length - 1];
        }
        this.isEmpty = function () {
            return item.length === 0;
        }
        this.size = function () {
            return item.length;
        }
        this.clear = function () {
            return item = [];
        }
    }

    function change2(number) {
        let stack = new Stack();
        let cacl;
        let output = '';

        while (number > 0) {
            cacl = Math.floor(number % 2);
            stack.push(cacl);
            number = Math.floor(number / 2);
        }

        while (!stack.isEmpty()) {
            output += stack.pop().toString();
        }

        return output;
    }

    /** Queue **/

    const Queue = function () {
        let item = [];

        this.content = function () {
            return item;
        }
        this.push = function (target) {
            item.push(target);
        }
        this.shift = function () {
            return item.shift();
        }
        this.peek = function () {
            return item[item.length - 1];
        }
        this.isEmpty = function () {
            return item.length === 0;
        }
        this.size = function () {
            return item.length;
        }
        this.clear = function () {
            return item = [];
        }
    }

    console.log(change2(209));

    /** Priority Queue **/
    //創建一個 Object
    function User(name, priority) {
        this.name = name; // item
        this.priority = priority; //優先順序
    }

    function PriorityQueue() {
        let items = [];

        this.dequeue = function () {
            return items.shift();
        };
        this.front = function () {
            return items[0];
        };
        this.isEmpty = function () {
            return items.length === 0;
        };
        this.size = function () {
            return items.length;
        };
        this.clear = function () {
            items = [];
        };
        this.enqueue = function (name, priority) {
            //建立佇列 Object
            let queueObj = new User(name, priority);

            // Object 是否已經有被排入佇列
            let isEnqueue = false;

            //如果佇列是空的, 直接插入
            if (this.isEmpty()) {
                items.push(queueObj);
                // console.log(items);
                return
            }

            //不是空的, 迴圈歷遍佇列, 比較優先值
            for (let i = 0; i < items.length; i++) {

                // 迴圈佇列, 如果優先順序小於當前 i 位置 item, 就插入
                if (priority < items[i].priority) {
                    items.splice(i, 0, queueObj);
                    // 表示 Object 已被排入佇列
                    isEnqueue = true;
                    return
                }
            }

            // 如果迴圈一圈, 都沒有找到能插入的位置, 直接插入佇列最後
            if (!isEnqueue) {
                items.push(queueObj);
            }
            // console.log(items);
        };
    }

    const queue = new PriorityQueue()
    queue.enqueue('Andy', 3);
    queue.enqueue('Billy', 2);
    queue.enqueue('Camila', 1);


    /** Circular Queue **/

    function circular(list, number) {
        //創建一個空佇列
        let queue = new Queue()

        //把 list item 全部都先放入佇列
        for (let i = 0; i < list.length; i++) {
            queue.push(list[i]);
        }

        //開始迴圈直到佇列內剩1個
        while (queue.size() > 1) {

            //開始每次都歷遍一次 list 全部
            for (let i = 0; i < number; i++) {
                //每次歷遍都把第一個移到最後一個
                queue.push(queue.shift());
            }

            //每次歷遍完, 都移除第一個 item
            let removeSomeOne = queue.shift();
            // console.log('被刪除的是: ' + removeSomeOne);
        }

        return queue.shift();
    }

    const user = ['Andy', 'Billy', 'Camila', 'David', 'Emily', 'Frank'];
    const startCircular = circular(user, 9)

    // console.log('最後剩下的是: ' + startCircular);

    /** Linked List **/

    function LinkedItem(element) {
        // 新增的鏈結 item
        this.element = element;

        // 指向下一個鏈結 item, 初始視為空
        this.nextItem = null;
    }

    function LinkedList() {
        // 當前鏈結的長度
        let length = 0;

        // 當前鏈結的第一個 item
        let head = null;

        this.append = function (element) {
            // 產生新 item 實例
            let node = new LinkedItem(element);
            let currentItem;

            if (head === null) {
                head = node;
            } else {
                currentItem = head;

                while (currentItem.nextItem) {
                    currentItem = currentItem.nextItem;
                }

                currentItem.nextItem = node;
            }
            length++;
        }
        this.insert = function (element, position) {
            // 判斷 position 是否超過鏈結
            if (position >= 0 && position <= length) {
                // 產生要插入的 item 實例
                let node = new LinkedItem(element);

                // 先將當前的 item 指向 head, 因為都要從頭一路找下去
                let currentItem = head;

                // 作為有2個以上 item 鏈結, 前一個指針的暫存
                let previous;

                // 當作有2個以上 item 鏈結, 對比 position 用的 index
                let index = 0;

                if (position === 0) {
                    // 若插入的位置是第一個, 將新 item 的 next 指向 currentItem (這邊是原本的head)
                    node.nextItem = currentItem;
                    // 把 head 改成新 item
                    head = node;
                } else {
                    // 如果 position 不是第一個, 用迴圈歷遍鏈結, index 當指標去找到 position 位置的 item
                    // 從 0 個 item 開始遞增去找
                    while (index++ < position) {
                        // previous 用來保存 currentItem 紀錄插入前的當前 item
                        // 準備將 previous 的 nextItem 給新 item
                        previous = currentItem;

                        // 把原本當前的 currentItem.nextItem 指向 currentItem, 往前移一位
                        // 騰出位子給新 item
                        currentItem = currentItem.nextItem;
                    }
                    node.nextItem = currentItem;
                    previous.nextItem = node;
                }
                length++;

                return true;
            } else {
                return false;
            }
        }
        this.removeAt = function (position) {
            // 判斷 position 是否超過鏈結
            if (position > -1 && position > length) {

                // 因為是從中移除, 所以必須從 head 開始一路找 nextItem 直到目標
                let currentItem = head;

                // 作為有2個以上 item 鏈結, 前一個指針的暫存
                let previous;

                // 當作有2個以上 item 鏈結, 對比 position 用的 index
                let index = 0;

                if (position === 0) {
                    // 如果 position 是第一個, 就直接把 head 指向下一個 nextItem
                    head = currentItem.nextItem;
                } else {
                    // 如果 position 不是第一個, 用迴圈歷遍鏈結, index 當指標去找到 position 位置的 item
                    // 從 0 個 item 開始遞增去找
                    while (index++ < position) {
                        // previous 用來保存 currentItem 紀錄移除前的上一個 item
                        previous = currentItem;

                        // 再把 currentItem.nextItem 指向 currentItem, 把 current 刷新成下一個
                        currentItem = currentItem.nextItem;
                    }
                }

                // 完成後再把 length 減少一個
                length--;

                // 最後把 return currentItem 的實例
                return currentItem.element;
            } else {
                return null;
            }
        }
        this.remove = function (element) {

        }
        this.indexOf = function (element) {

        }
        this.isEmpty = function () {

        }
        this.size = function () {
            return length;
        }
    }

    const testList = new LinkedList();

    testList.append({key: 1});
    testList.append({key: 2});
    testList.append({key: 4});
    testList.append({key: 5});

    console.log(testList.size());

    testList.insert({key: 3}, 2);
</script>
</body>
</html>
