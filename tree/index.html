<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>Tree</title>
</head>
<body>
<script>

    function Node(key) {
        // key 就是子節點
        this.key = key;
        this.left = null;
        this.right = null;
    }

    function addNode(node, newNode) {
        // 若 newNode key 小於 node key 表示放入左側
        if (newNode.key < node.key) {

            // 若當前左側都為空, 就插入
            if (node.left === null) {
                node.left = newNode;
            }
            // 若當前左側不為空的的話, 遞迴使用 addNode 直到找到可插入點
            else {
                addNode(node.left, newNode);
            }
        }
        // 若 newNode key 大於 node key 表示放入右側
        else {
            // 若當前右側都為空, 就插入
            if (node.right === null) {
                node.right = newNode;
            }
            // 若當前右側不為空的的話, 遞迴使用 addNode 直到找到可插入點
            else {
                addNode(node.right, newNode);
            }
        }
    }

    function logNode(value) {
        console.log(value);
    }

    function BinarySearchTree() {
        let root = null;

        this.insert = function (key) {
            // 創建子節點
            let newNode = new Node(key);

            // 整個 tree 都是空的話, 新子節點當成 root
            if (root === null) {
                root = newNode;
            }
            // tree 不是空的話, 遞迴使用 addNode function 尋找插入點
            else {
                addNode(root, newNode);
            }

        }

        // 中序遍歷：是由小到大的升冪順序查訪節點方式, 也是一種排序
        this.inOrderTraverse = function(callback) {
            // 從 root 出發
            this.inOrderTraverseNode(root, callback);
        }

        this.inOrderTraverseNode = function (node, callback) {
            // 若當前 node 不為空的話就繼續查訪下去
            if (node !== null) {

                // 先從左邊開始查訪, 因為當前左邊的是較小的
                this.inOrderTraverseNode(node.left, callback);

                callback(node.key);

                // 先從右邊開始查訪, 因為當前右邊的是較大的
                this.inOrderTraverseNode(node.right, callback);
            }
        }

        // 先序遍歷：是以後代節點為優先的順序, 去訪問每個節點
        // 1.會以訪問本身節點為開始
        // 2.在一路訪問左側的節點到底
        // 3.最後在訪問右側的節點
        this.preOrderTraverse = function(callback) {
            // 從 root 出發
            this.preOrderTraverseNode(root, callback);
        };

        this.preOrderTraverseNode = function(node, callback) {
            // 若當前 node 不為空的話就繼續查訪下去
            if (node !== null) {
                callback(node.key);
                this.preOrderTraverseNode(node.left, callback);
                this.preOrderTraverseNode(node.right, callback);
            }
        };
    }

    const testTree = new BinarySearchTree();

    testTree.insert(18);
    testTree.insert(9);
    testTree.insert(11);
    testTree.insert(4);
    testTree.insert(33);
    testTree.insert(2);
    testTree.insert(17);
    testTree.insert(26);

    // testTree.inOrderTraverse(logNode);
    testTree.preOrderTraverse(logNode);


</script>
</body>
</html>
