<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>Closure</title>
</head>
<body>
<div id="show-count1"></div>
<button onclick="count1.add()">count1 add</button>
<button onclick="count1.less()">count1 less</button>
<br/>
<div id="show-count2"></div>
<button onclick="count2.add()">count2 add</button>
<button onclick="count2.less()">count2 less</button>
<script>
    function CreateCount(target, value) {
        this.value = value;
        this.init = () => {
            document.getElementById(target).innerHTML = this.value;
        };
        this.add = () => {
            this.value++;
            document.getElementById(target).innerHTML = this.value;
        };
        this.less = () => {
            this.value--;
            document.getElementById(target).innerHTML = this.value;
        };
    }

    const count1 = new CreateCount('show-count1', 10);
    const count2 = new CreateCount('show-count2', 50);

    count1.init();
    count2.init();


    function parent() {
        let count = 0;

        function add() {
            console.log(++count);
        }

        function less() {
            console.log(--count);
        }

        return {
            addCount: add,
            lessCount: less
        };
    }

    const test = parent();

    test.addCount();
    test.addCount();
    test.lessCount();


    // function a(){　　//建立函數a
    //     let i=0;　　　　//定義變量i
    //     function b(){　　　　//在函數a內套入函數b
    //         console.log(++i);　　　　//提示框，輸出i的值
    //     }
    //     return b;　　　　　　//返回函數b的值
    // }
    //
    // const c = a();　　　　//將函數a賦給變量c
    // c();
    // c();
    // c();

    /** 這個只想最後拖動放開時 call 一次, 而不是隨著拖動狂 call **/
        // window.onresize = function(){
        //     console.log('我變換視窗大小了')
        // }

    /** 方法:使用一般寫法 **/
    // 缺點: 控制是否執行的變數 time 放在外部, 可能被東西竄改值
    let time = null;

    const log = function () {
        console.log('我變換視窗大小了');
    }

    window.onresize = function () {
        debounce1(log);
    }

    function debounce1(doFunction) {
        if (time) {
            clearTimeout(time);
            time = null;
        }

        time = setTimeout(function () {
            doFunction();
        }, 1000)
    }

    /** 方法:使用閉包 **/
        // 優點: 控制是否執行的變數 timer 所在 function 內部, 外部的東西是無法影響這個變數的
    const callFunction = function () {
        console.log('我變換視窗大小了')
    }

    window.onresize = debounce(callFunction);

    function debounce(doFunction) {
        // 當閉包裡的 timer 第一次被執行後, 就會保留在記憶體內,
        // 因為 return function 內有用到變數 timer
        // 所以 js 會判定變數 timer 還有引用, 不用被記憶體回收清掉
        // 且 timer 被鎖在 debounce 中, 外部的東西是無法影響這個變數的
        let timer = null;
        return function () {
            if (timer) {
                clearTimeout(timer);
                timer = null;
            }
            timer = setTimeout(function () {
                doFunction();
            }, 1000)
        }

    }

</script>
</body>
</html>
