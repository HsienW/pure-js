<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>Simulate Simple Fiber</title>
</head>
<body>
<script>

    /* RequestIdleCallback test*/

    // let count = 0;
    //
    // const loopWork = setInterval(() => {
    //     if (count <= 5) {
    //         count++;
    //         console.log('event loop working');
    //     } else {
    //         clearInterval(loopWork);
    //     }
    // }, 1000)

    // const fakeApi = function () {
    //     return new Promise((resolve, reject) => {
    //         const success = true;
    //         if (success) {
    //             setTimeout(() => {
    //                 resolve({
    //                     userName: 'demo',
    //                     token: '1234567890'
    //                 });
    //             }, 2000);
    //         } else {
    //             reject([]);
    //         }
    //     });
    // };

    // window.requestIdleCallback((deadline) => {
    //     console.log('進入');
    //     while (deadline.timeRemaining() > 0) {
    //         console.log(deadline.timeRemaining());
    //
    //         console.log('do some thing');
    //         // fakeApi().then(data => {
    //         //     console.log(data);
    //         // });
    //     }
    // });

    // 一個 Virtual Dom 下的 Node 展開後, 類似下面這個 element object
    let element = {
        tagName: 'ul',  // Node 標籤名
        props: {  // DOM 的屬性，用一個對象存儲鍵值對
            id: 'list'
        },
        children: [  // Node 的子節點
            {tagName: 'li', props: {class: 'item'}, children: ["Item 1"]},
            {tagName: 'li', props: {class: 'item'}, children: ["Item 2"]},
            {tagName: 'li', props: {class: 'item'}, children: ["Item 3"]},
        ]
    }

    /**
     Fiber 是深度優先的去歷遍 DOM (樹) 的鍊表, 該鍊表具有 3種節點 & 4種節點關係:

     節點:
     1.prevNode = 當前的上一個節點, 通常指向 子節點 (child)
     2.currentNode = 當前執行 task 的節點
     3.nextNode = 當前執行 task 的節點, 通常指向 子節點 (child)

     關係:
     1.root = 初始節點, 通常具有子節點 (child), 沒有兄弟節點 (sibling)
     2.child = 子節點之一, 具有一定有父節點, 兄弟節點可有可無
     3.sibling = 子節點之一, 具有一定有父節點, 兄弟節點可有可無, 通常為樹中第一個 child 節點右側的節點 (同層)
     4.return = 因深度優先的規則, 當沒有 child 時會往右邊 (sibling) 尋找, 當 sibling 也找完之後, 指針會往上一層的父節點指,
                此時會產生同個節點, 二次出現在指向的路線中, 所以 return 的節點(當下層的父節點)不會作為 nextNode (下一個 task)
                只有 child 和 sibling 才會當成下一個 nextNode
     **/

    function workLoopSync(deadline) {
        // 迴圈會在 task 做完 or timeRemaining (event loop) 的空閒時間快沒了的時後結束

        // Step1 確認當前是否有 fiber task & event loop 的空檔可以做事
        while(nextPartOfWork && deadline.timeRemaining() > 1) {

            // Step2 兩者都有, 開始執行 fiber task
            nextPartOfWork = performPartOfWork(nextPartOfWork);
        }

        // Step3 如果 task 沒做完, 但時間要結束了
        // 把剩餘的 task 註冊到下一次的 requestIdleCallback
        window.requestIdleCallback(workLoopSync);
    }

    // Step4 performUnitOfWork 是執行的 function
    // 參數是當前的 fiber task，同時它會 return 下一個 task
    function performPartOfWork(partTask) {

        // partTask 的 dom 就是每個要執行 fiber 任務的 root dom (也可當作是 render container)
        // 如果當前的 partTask 沒有這個屬性, 表示它不是 root dom
        // 所以需要在 partTask 創建這個 dom, 並掛上去
        if(!partTask.dom) {

            // todo should add createDom function to example
            partTask.dom = createDom(partTask);
        }

        // 如果當前的 partTask 有父節點, 表示為要 render 的子節點, 同時它可能有同層的兄弟節點
        // 所以需要在 partTask 的父節點掛上去這個 dom
        if(partTask.return) {
            partTask.return.dom.appendChild(partTask.dom);
        }

        // 開始把虛擬 dom 結構轉換成 fiber 結構
        const currentTaskNodes = partTask.children;

        // 先定義當前 partTask 的兄弟節點為空
        let prevNode = null;

        // 確認當前的 currentTaskNodes (children) 是有值的
        if(currentTaskNodes && currentTaskNodes.length) {

            // 取出每個 currentTaskNodes, 執行轉換
            for(let i = 0; i < currentTaskNodes.length; i++) {

                // 每個取出的 Node 都會轉為一個 fiber task 以供鍊表往上 or 往下查詢
                let newTask = {
                    tagName: currentTaskNodes[i].tagName,
                    props: currentTaskNodes[i].props,
                    return: partTask,
                    dom: null
                }

                // 當 child 是第一個子節點時, 把 partTask 的 child 屬性指向它, 用以完成鍊表的指向
                if(i === 0) {
                    partTask.child = newTask;
                } else {
                    // 每個子節點, 都有指向下一個 newTask (下一個子節點) 的 sibling 屬性
                    prevNode.next = newTask;
                }

                prevNode = newTask;
            }
        }
    }
    window.requestIdleCallback(workLoopSync);

</script>
</body>
</html>
